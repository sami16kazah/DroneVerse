import jsPDF from "jspdf";
import autoTable from "jspdf-autotable";

export interface IReport {
  _id: string;
  clientName: string;
  createdAt: string;
  damages: {
    turbine: string;
    blade: string;
    side: string;
    imageUrl: string;
    imagePublicId: string;
    annotations: any[];
    filters?: any;
  }[];
}

export const generatePDF = async (report: IReport) => {
  const doc = new jsPDF();
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 15;
  let yPos = margin;

  // --- Header ---
  // Logo (Text for now, can be replaced with image if available)
  doc.setFontSize(22);
  doc.setTextColor(0, 102, 204); // DroneVerse Blue
  doc.text("DroneVerse", margin, yPos);
  
  // Report Title
  doc.setFontSize(16);
  doc.setTextColor(60, 60, 60);
  doc.text("Inspection Report", pageWidth - margin, yPos, { align: "right" });
  
  yPos += 10;
  
  // Line separator
  doc.setDrawColor(200, 200, 200);
  doc.line(margin, yPos, pageWidth - margin, yPos);
  yPos += 10;

  // --- Client Info ---
  doc.setFontSize(12);
  doc.setTextColor(0, 0, 0);
  doc.text(`Client: ${report.clientName}`, margin, yPos);
  doc.text(`Date: ${new Date(report.createdAt).toLocaleDateString()}`, pageWidth - margin, yPos, { align: "right" });
  yPos += 15;

  // --- Content ---
  // Group damages by Turbine -> Blade
  const groupedDamages = report.damages.reduce((acc, dmg) => {
    const key = `${dmg.turbine} - ${dmg.blade}`;
    if (!acc[key]) acc[key] = [];
    acc[key].push(dmg);
    return acc;
  }, {} as Record<string, typeof report.damages>);

  for (const [groupTitle, damages] of Object.entries(groupedDamages)) {
    // Check for page break
    if (yPos > pageHeight - 40) {
      doc.addPage();
      yPos = margin;
    }

    // Section Header
    doc.setFillColor(240, 240, 240);
    doc.rect(margin, yPos, pageWidth - (margin * 2), 10, "F");
    doc.setFontSize(12);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(0, 0, 0);
    doc.text(groupTitle, margin + 2, yPos + 7);
    yPos += 15;

    for (const damage of damages) {
      // Image Block
      const imgWidth = 80;
      const imgHeight = 60;
      
      // Check space for image + text
      if (yPos + imgHeight + 20 > pageHeight - margin) {
        doc.addPage();
        yPos = margin;
      }

      // Add Image
      try {
        // Fetch image to get base64 or use direct URL if supported (jspdf supports URL in addImage in some envs, but base64 is safer)
        // For simplicity in client-side, we'll try passing the URL directly. 
        // Note: CORS might be an issue. If so, we'd need to fetch and convert to base64.
        // Let's assume standard img tag loading works or we use a helper.
        // Actually, jsPDF addImage often needs base64. Let's try a helper to fetch blob.
        const imgData = await fetchImageAsBase64(damage.imageUrl);
        doc.addImage(imgData, "JPEG", margin, yPos, imgWidth, imgHeight);
      } catch (e) {
        doc.text("[Image Load Failed]", margin, yPos + 20);
      }

      // Details next to image
      const textX = margin + imgWidth + 10;
      let textY = yPos + 10;

      doc.setFont("helvetica", "normal");
      doc.setFontSize(10);
      doc.text(`Side: ${damage.side}`, textX, textY);
      textY += 7;

      // Crack Levels / Annotations
      if (damage.annotations && damage.annotations.length > 0) {
        doc.text("Detected Issues:", textX, textY);
        textY += 7;
        damage.annotations.forEach((ann, idx) => {
            // Assuming annotation has some 'crackLevel' or similar property, or we just list them
            // Based on previous context, annotations might just be shapes, but user asked for "crack level".
            // If crack level isn't explicit, we'll list the annotation type or index.
            // Let's assume there might be a 'crackLevel' property or we default to "Issue #{idx+1}"
            const label = (ann as any).crackLevel ? `Crack Level: ${(ann as any).crackLevel}` : `Issue #${idx + 1}`;
             doc.text(`- ${label}`, textX + 5, textY);
             textY += 5;
        });
      } else {
        doc.text("No specific issues marked.", textX, textY);
      }

      yPos += imgHeight + 10;
    }
    
    yPos += 5; // Extra spacing between groups
  }

  // Footer
  const pageCount = doc.getNumberOfPages();
  for(let i = 1; i <= pageCount; i++) {
      doc.setPage(i);
      doc.setFontSize(8);
      doc.setTextColor(150);
      doc.text(`Page ${i} of ${pageCount}`, pageWidth / 2, pageHeight - 10, { align: "center" });
      doc.text("Generated by DroneVerse", pageWidth - margin, pageHeight - 10, { align: "right" });
  }

  doc.save(`Report_${report.clientName.replace(/\s+/g, "_")}_${Date.now()}.pdf`);
};

// Helper to fetch image and convert to base64
async function fetchImageAsBase64(url: string): Promise<string> {
  try {
    const response = await fetch(url, { mode: 'cors' }); // Ensure CORS is handled or images are on same domain/allowed
    const blob = await response.blob();
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result as string);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  } catch (error) {
    console.error("Error fetching image for PDF:", error);
    return "";
  }
}
